1. run GDB in quiet mode

  gcc -q 
  
2. see source code


  list

3. Putting break point and deleting breakpoints

break <line number> 

 eg: break 6
  
  
delete breakpoints  [deletes all breakpoints]


4. examine memory 
 
 command - x 
 
 
 x/8x = examine 8 hexadecimal words
 
 x/8x &array    = examine 8 hexadecimal words startding from the location of the array variable
 

5. To see memory used by my program 


 Info proc mappings
 
 
 [GET THE STACK ADDRESS FROM HERE, SIZE OF THE STACK]
 
6. Show assembly code
 
 disassemble main          [disassambles the main function]
 
7. Resumes Execution

continue

8. see registers

info Registers
  
  
  **In case of stripped binary**
  
Steps :

1. open binary in gdb
2. use command “info files”   [.text section contains the part where the code is loaded, so the address it starts from is the offset for .text section possibly also the main]
3. Examine the code at the found address

     x/20i <found address>          [examine/20instructions from mentioned address]      (set disassembly-flavor intel  to change format from AT&T to Intel)

We check the first call function in the showed instructions in gdb and ghidra ... in ghidra we can see the __libc_start_main function 
Note* - in a typycal binary first call function calls the libc_start_main function we can crosscheck that in ghidra

Address of RDI is the address of the main function


4. Alternatively we can set breakpoint at the __libc_start_main function as for that I have symbol as I know the location of __libc_start_main



5. Base address when running in Linux machine always changes due to ASLR and it has to be found out and the offset found needs to be added to it to get the actual address of the main function
 
using this command “info proc mapping” we can  see the memory map of the running programs, here the start address is basically the base address

Note** - gdb disables ASLR so once the address is found re running the program wont change the adress maps.

6. set breakpoint at the found address i.e base address + offset address        



WAY 2 

1. break _start  [set a pending breakpoint]
2. once breaks at _start which is inside the dynamic library of ld_linux
3. then use the command “info proc mappings”
4. now continue from step 5
5. To verify disassemble by

x/20i <main-func-address>



Note** - GHIDRA loads binaries from 0x0010000 by default 

WAY 3

1. run the binary ./nameof-binary without arguments so that it keeps running
 
2. run this command  in bash “pidof <binary-name>” 

3. cat /proc/pidof-binary/maps                       [We will get the base address at this location] 

4. Set breakpoint in gdb now 

5. To verify disassemble by

x/20i <main-func-address> 

WAY 4

1. We can disable ASLR by

echo 0 >  /proc/sys/kernel/randomize_va_space

2. cat /proc/'pidof binary-name'/maps                  [this would give the base address]

3. Set breakpoint in gdb now

4. To verify disassemble by

x/20i <main-func-address>


WAY 5 [using gdb and ghidra to find the main function address]

1. info proc mappings     in gdb
2. click memory mapping in ghidra > click the house icon for setting base address > paste the base address found from gdb here 

3. Now get the actual main function address from ghidra 
4. Set breakpoint in gdb now

5. To verify disassemble by

x/20i <main-func-address>  
